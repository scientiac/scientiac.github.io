<!doctype html><html lang=en><head><meta charset=utf-8><script>(()=>{try{const a={light:`gruvbox-light`,dark:`night-solis`};const b=window.matchMedia(`(prefers-color-scheme: dark)`).matches;const c=localStorage.theme||(b?a.dark:a.light);document.documentElement.dataset.theme=c}catch(a){}})()</script><link href=/assets/css/themes.css rel=stylesheet><link href=/assets/css/readable.css rel=stylesheet><link href=/assets/css/global.css rel=stylesheet><link href=/assets/css/fonts.css rel=stylesheet><link href=/assets/css/logo.css rel=stylesheet><link href=https://scientiac.space/atom.xml rel=alternate title=RSS type=application/atom+xml><meta content=scientiac.space property=og:site_name><meta content=https://scientiac.space/res/thumbnail-light.png property=og:image><link rel="shortcut icon" href=/res/thumbnail.svg type=image/x-icon><meta content="width=device-width,initial-scale=1" name=viewport><meta content="rgb(253, 246, 227)" name=theme-color><script defer src=/assets/js/copy-button.js></script><link href=https://github.com/scientiac rel=me><link href=mailto:spandan@scientiac.space rel=me><link href=https://webmention.io/scientiac.space/webmention rel=webmention><meta content=@iac@polymaths.social name=fediverse:creator><body onload=updateThemeSelector();><div class=logo-container><a href=/> <div class=inner-logo-container></div> </a></div><nav data-style=classy><span><a href=/>Main</a></span><span><a href=/blog>Blog</a></span><span><a href=/syndications>Ping</a></span><span><a href=/more>More</a></span></nav><section class=section-body><div class=container><div class=logs><p class="subtitle --center"><code class=dateandtag><a href=atom.xml>RSS</a></code><h1 class=title-writings>POSSE</h1><article class=syndicate><h2><a href=https://scientiac.space/syndications/kl-os-2026-01-05/>KL-OS: File System</a></h2><p class="subtitle --center"><code>2026-01-05</code><div class=syndicate-text><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p><a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-15.md>Day 15</a> was about File System.<p>The <a href=https://operating-system-in-1000-lines.vercel.app/en/>book</a> that I am following has come to an end with <strong>File System</strong> as the final chapter where it teaches to implement <code>tar</code> file as a filesystem.<p><code>tar</code> is an archive format (like zip) that can contain multiple files. It contains file contents, filenames, creation dates, and other information necessary for a filesystem. Compared to common filesystem formats like FAT or ext2, tar has a much simpler data structure.<p>First a simple directory with two files is made as an example which is then archived/compressed into the <code>tar</code> format using the command line <code>tar</code> tool. Which, also is added to the <code>buildscript</code> before launching the <code>qemu</code> VM.<pre class=language-sh data-lang=sh style=color:#fdf4c1aa;background-color:#282828><code class=language-sh data-lang=sh><span>(</span><span style=color:#fabd2f>cd</span><span style=color:#fdf4c1> disk </span><span style=color:#fe8019>&& </span><span style=color:#fdf4c1>tar cf ../disk.tar --format</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>ustar </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>.txt</span><span>)
</span><span>
</span><span style=color:#928374;font-style:italic># The following flag is also added to qemu.
</span><span style=color:#fdf4c1>-drive id=drive0,file=disk.tar,format=raw,if=none \
</span></code></pre><p>To read the filesystem, first, the data structures related to the tar filesystem is defined in <code>kernel.h</code>. This implementation has all files read from the disk at boot.<p>To write to the disk, the contents of the <code>files</code> variable is written back to the disk in the tar file format. The <code>files</code> variable contains the copy of the <code>disk</code> variable declared as a static variable (It is a temporary buffer and, since the stack has a limited size it is preferred to use static variable instead of local <code>stack</code> variable.) which contains the disk image.<p>File read/write system calls are then designed in the <code>user.c</code> and <code>user.h</code> files and then the system calls are implemented on the kernel files and then the system calls are implemented in the kernel. We also add the read and write commands to the shell.<p>But, we still have to address the user pointers.<p>In RISC-V, the behaviour of <code>S-Mode</code> (kernel) can be configured through <code>sstatus</code> <code>CSR</code>, including SUM (permit Supervisor User Memory access) bit. When SUM is not set, <code>S-Mode</code> programs (i.e. kernel) cannot access U-Mode (user) pages.<p>All we need to do is to set the SUM bit when entering user space and voila! Our OS with a filesystem implementation is now ready.</div></article><article class=syndicate><h2><a href=https://scientiac.space/syndications/kl-os-2026-01-04/>KL-OS: Disk I/O</a></h2><p class="subtitle --center"><code>2026-01-04</code><div class=syndicate-text><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p><a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-14.md>Day 14</a> was about Disk <code>I/O</code>.<p>A device driver for the <code>virtio-blk</code>, a virtual disk device was implemented.<p><code>Virtio</code> is one of the APIs for device drivers to control devices. It is widely used in virtualization environments such as QEMU. The <code>virtio</code> devices have a structure called <code>virtqueue</code> and it is a queue shared between the driver and the device. It consists of <code>Discriptor Table</code>, <code>Available Ring</code> and <code>Used Ring</code>.<p>First we enable <code>virtio</code> drivers in our <code>buildscript</code> which is <code>run.sh</code>. We use the following flags for <code>qemu</code>:<pre class=language-sh data-lang=sh style=color:#fdf4c1aa;background-color:#282828><code class=language-sh data-lang=sh><span>    </span><span style=color:#fdf4c1>-drive id=drive0,file=lorem.txt,format=raw,if=none
</span><span>    </span><span style=color:#fdf4c1>-device virtio-blk-device,drive=drive0,bus=virtio-mmio-bus.0
</span></code></pre><p>Here, <code>lorem.txt</code> is a file made for testing purposes beforehand.<p>Then, the definition of <code>c</code> structs and macros is done in <code>kernel.h</code>. To access the <code>MMIO</code> registers we add that functionality in <code>kernel.c</code>.<p>The <code>create_process</code> function is modified to map the <code>virtio-blk</code> <code>MMIO</code> region to the page table so the kernel can access the <code>MMIO</code> registers. <code>MMIO</code> region to the page table so the kernel can access the <code>MMIO</code> registers.<p>Then the <code>Virtio Device Initialization</code> and <code>Virtqueue Initialization</code> is done with the process described in the <a href=https://ozlabs.org/~rusty/virtio-spec/virtio-0.9.5.pdf>spec</a>.<p><code>I/O</code> requests to the disk is implemented by "adding processing requests to the <code>virtqueue</code>".<p>A request is sent in the following steps:<ol><li>Construct a request in <code>blk_req</code>. Specify the sector number you want to access and the type of read/write.<li>Construct a descriptor chain pointing to each area of <code>blk_req</code> (see below).<li>Add the index of the head descriptor of the descriptor chain to the Available Ring.<li>Notify the device that there is a new pending request.<li>Wait until the device finishes processing (aka busy-waiting or polling).<li>Check the response from the device.</ol><p>To test, we initialize the <code>virtio</code> device in the kernel main and try reading and writing to the disk with the implemented functions.<blockquote><p>Device drivers are just "glue" between the OS and devices. Drivers don't control the hardware directly; drivers communicate with other software running on the device (e.g., firmware). Devices and their software, not the OS driver, will do the rest of the heavy lifting, like moving disk read/write heads.</blockquote></div></article><article class=syndicate><h2><a href=https://scientiac.space/syndications/kl-os-2026-01-03/>KL-OS: System Call</a></h2><p class="subtitle --center"><code>2026-01-03</code><div class=syndicate-text><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p><a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-13.md>Day 13</a> was about system call.<p>Similar to <code>SBI Call</code> implementation, the system calls are invoked in a similar way.<p>The <code>syscall</code> function sets the system call number in the <code>a3</code> register and the system call arguments in the <code>a0</code> to <code>a2</code> registers, then executes the <code>ecall</code> instruction. The <code>ecall</code> instruction is a special instruction used to delegate processing to the kernel. When the <code>ecall</code> instruction is executed, an exception handler is called, and control is transferred to the kernel. The return value from the kernel is set in the <code>a0</code> register.<p>The first <code>systemcall</code> implemented is <code>putchar</code>. It takes a character as the first argument and the second and subsequent unused arguments are set to 0.<p>Then the <code>ecall</code> instruction is handled in the kernel. The calling of <code>ecall</code> can by determined by checking the value of <code>scause</code>. Before calling the <code>handle_syscall</code> function we also add the size of <code>ecall</code> instruction (4) to the value of <code>sepc</code>.<p>This is because <code>sepc</code> points to the program counter that caused the exception, which points to the <code>ecall</code> instruction. If we don't change it, the kernel goes back to the same place, and the <code>ecall</code> instruction is executed repeatedly.<p>Then a <code>system call</code> handler is made and is called from trap handler. It receives a structure of registers at the time of exception that was saved in the trap handler. It determined the type of system call by checking the value of <code>a3</code> register.<p>The system call was then tested with a main print function in <code>shell.c</code>.<p>An <code>exit</code> system call is also implemented where it takes the first argument as <code>3</code> which is defined as <code>SYS_EXIT</code>.<p>The system call changes the process state to <code>PROC_EXITED</code>, and calls yield to give up the CPU to other processes. The scheduler will only execute processes in <code>PROC_RUNNABLE</code> state, so it will never return to this process. However, <code>PANIC</code> macro is added to cause a panic in case it does return.<p>A bare-bones shell was then implemented to use the syscalls to perform actions from the user mode.</div></article><article class=syndicate><h2><a href=https://scientiac.space/syndications/kl-os-2026-01-02/>KL-OS: User Mode</a></h2><p class="subtitle --center"><code>2026-01-02</code><div class=syndicate-text><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p><a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-12.md>Day 12</a> was about user mode.<p>The application that we had made had to be run on the user mode. And since, the execution image is a raw binary, it needs to be prepared with a fixed binary.<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>#define </span><span style=color:#8ec07c>USER_BASE </span><span style=color:#d3869b>0x1000000
</span></code></pre><p>After defining the symbols to use in the embedded raw binary, the create process function is updated to start the application from the <code>user_entry</code>.<p>The <code>create_process</code> is modified to take the pointer to the execution image and image size as arguments. It copies the execution image page by page for the specified size and maps it to the process page table.<p>Finally, the <code>create_process</code> function is modified to create a user process.<p>After checking if the execution image is mapped as expected, to run applications we must transition the CPU to the user mode. Or, in RISC-V, the U-Mode.<p>This switch from <code>S-Mode</code> to <code>U-mode</code> is done with the <code>sret</code> instruction. It does two writes to CSRs while switching:<ul><li><code>PC</code> is set for when transitioning in U-Mode in the <code>sepc</code> register where <code>sret</code> jumps to.<li>Then, setting <code>SPIE</code> bit in the <code>sstatus</code> register enables hardware interrupts and the handler set in the <code>stvec</code> register will be called while entering the <code>U-Mode</code>.</ul></div></article><article class=syndicate><h2><a href=https://scientiac.space/syndications/kl-os-2026-01-01/>KL-OS: Application</a></h2><p class="subtitle --center"><code>2026-01-01</code><div class=syndicate-text><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p><a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-11.md>Day 11</a> was about application.<p>First, a linker script named <code>user.ln</code> was made this time starting at address <code>1000000</code> so that the application doesn't overlap with the kernel space.<p>Then a simple <code>userland</code> library is created with minimal features just enough to indicate the existence of a userland application. A header file for the userland library is also made.<p>Then an application is made, very <code>barebones</code>, it is just an infinite loop for now since there is no way to print characters at the moment.<p>To build the application, we first compile it with cc to get an executable in a <code>ELF</code> format. The executable is then converted to raw binary format with the <code>objcopy</code> tool. Then the raw binary executable format is then again converted to a format that can be embedded in the C language.<p>Lastly, the <code>shell.bin.o</code> output is then passed to <code>clang</code> (kernel build section of the script) which gets embedded into the kernel image.</div></article><article class=syndicate><h2><a href=https://scientiac.space/syndications/kl-os-2025-12-31/>KL-OS: Examining Pages</a></h2><p class="subtitle --center"><code>2025-12-31</code><div class=syndicate-text><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p><a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-10.md>Day 10</a> was about testing and debugging paging and page table contents.<p>Running the <code>buildscript</code> should give us the exact same output of repeating letters similar to how it was before paging was implemented.<p>Then the page table contents were examined. To check about the registers, following command was run on the <code>qemu</code> console.<pre class=language-sh data-lang=sh style=color:#fdf4c1aa;background-color:#282828><code class=language-sh data-lang=sh><span>(</span><span style=color:#fdf4c1>qemu</span><span>)</span><span style=color:#fdf4c1> info registers
</span></code></pre><p>Then the value of <code>satp</code> register is read and then interpreted by doing the following hexadecimal math:<pre class=language-py data-lang=py style=color:#fdf4c1aa;background-color:#282828><code class=language-py data-lang=py><span style=color:#fabd2f>hex</span><span style=color:#fdf4c1>((0x</span><span style=color:#fe8019><</span><span style=color:#fdf4c1>val of satp</span><span style=color:#fe8019>> & </span><span style=color:#d3869b>0x3fffff</span><span style=color:#fdf4c1>) </span><span style=color:#fe8019>* </span><span style=color:#d3869b>4096</span><span style=color:#fdf4c1>)
</span></code></pre><p>Then the <code>VPN[1]</code> and <code>VPN[0]</code> physical addressed were also examined.<p>The consequences of forgetting to set the paging mode, specifying physical address instead of physical page number was also seen. <code>qemu</code> logs were also enabled.</div></article><article class=syndicate><h2><a href=https://scientiac.space/syndications/kl-os-2025-12-30/>KL-OS: Page Table</a></h2><p class="subtitle --center"><code>2025-12-30</code><div class=syndicate-text><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p><a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-9.md>Day 9</a> was about memory management and virtual addressing.<p>The structure of the virtual address is defined by the RISC-V paging mechanism called <code>Sv32</code>. It uses a two level page table where the 32 bit virtual address is divided into a first-level page table index, a second level and a page offset. The tables are named <code>VPN[1]</code> and <code>VPN[0]</code> respectively.<p>First the macros for the construction of the page table are defined. Then the function to map pages <code>map_page</code> is made which is utilized in process creation. For that we also add an element called <code>page_table</code> on the <code>struct</code> of process. And to make everything work we define the starting address of the kernel space <code>__kernel__base</code> in the linker script just after boot.<p>To utilize the above setup of page tables and switch them, we specify the first-level page table in <code>satp</code> (Supervisor Address Translation and Protection) register.<p>I still need to understand more about this. I am not satisfied with the explanation from the resource.</div></article><article class=syndicate><h2><a href=https://scientiac.space/syndications/kl-os-2025-12-29/>KL-OS: Process</a></h2><p class="subtitle --center"><code>2025-12-29</code><div class=syndicate-text><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p><a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-8.md>Day 8</a> was about Process. Though, modern operating systems use the concept of threads to provide execution context. We treat processes like individual threads being run for our implementation.<p>First we define a structure for PCB (Process Control Block). We first define <code>PROC_UNUSED</code> and <code>0</code> and <code>PROC_RUNNABLE</code> as <code>1</code>. Then we create a structure for a unit process with the following slots:<ul><li>Process ID as an Integer.<li>State (<em><code>PROC_UNUSED </code>or <code>PROC_RUNNABLE</code></em>) as an Integer as defined before.<li>Stack Pointer as a <code>vaddr_t</code> (Virtual Address Type).<li>Kernel Stack as a list of unsigned <code>8bit</code> Integers.</ul><p>The Kernel Stack is essential for saving the registers while context switching.<p>Then, we defined the <code>switch_context</code> function that does the context switching. It takes the previous and next stack pointer as arguments and then switches them during execution. It saves the callee-saved registers into the stack, switches the stack pointer then restores the callee-saved registers from the stack. <em>The execution context is saved as a temporary local variable on the stack.</em><p>Then, we work on process creation. The process creation function <code>create_process</code> takes in the entry point of the process as a parameter and then returns the process struct.<p>The <code>delay</code> function is also created to act as a sleep style function which just does <code>nop</code> (Nothing) for 30000000 clock pulses.<p>Then a <strong>scheduler</strong> is made to make the context switching more autonomous. A scheduler is basically a Kernel program which decides the next process.<p>Then, in the exception handler, we make it so that each process has it's own independent kernel stack. While switching, the contents of <code>sscratch</code> are switched too to resume the execution of process from where it was interrupted as if nothing had happened.</div></article><article class=syndicate><h2><a href=https://scientiac.space/syndications/kl-os-2025-12-28/>KL-OS: Memory Allocation</a></h2><p class="subtitle --center"><code>2025-12-28</code><div class=syndicate-text><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p><a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-7.md>Day 7</a> was about Memory Allocation. First the memory regions were defined in the linker script so that it can determine the position to avoid overlapping the memory to kernel's static data.<p>The size of the memory space was <code>64 * 1024 * 1024</code> bytes or <code>64MB</code> and it is aligned to a <code>4KB</code> boundary.<p>Then a function <code>alloc_pages</code> was implemented which allocated <code>n</code> pages of memory and returned it's starting address.</div></article><article class=syndicate><h2><a href=https://scientiac.space/syndications/kl-os-2025-12-27/>KL-OS: Exceptions</a></h2><p class="subtitle --center"><code>2025-12-27</code><div class=syndicate-text><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p><a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-6.md>Day 6</a> was about Exceptions and handling those Exceptions in the kernel.<p>In RISC-V the CPU first checks <code>medeleg</code> register to determine which operation mode should handle the exception. In our case <code>U-mode/S-mode</code> is already handled by <code>OpenSBI</code>. Then, the CPU saves states into various <code>CSRs</code>. <code>stvec</code> register is set to <code>pc</code> then the exception is handled using the handler. Then <code>sret</code> is called to resume execution from the point where exception occurred.<p>The <code>handle_trap</code> function reads why the exception occurred and triggers the kernel panic. Which was implemented yesterday.</div></article><article class=syndicate><h2><a href=https://scientiac.space/syndications/kl-os-2025-12-26/>KL-OS: PANIC</a></h2><p class="subtitle --center"><code>2025-12-26</code><div class=syndicate-text><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p>Perfect topic for today because early morning I was shown why It was a stupid decision to do something, then at afternoon I got into a bike accident. Though it was minor with no injuries to both parties except some scratches on the bikes. It could have caused huge consequences. Then I did another mistake and then another.<p>PANIC!<p>It is <a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-5.md>day 5</a>. Implementing panic was very easy, it is implemented as a macro because if we defined it as a function it would have printed the <code>__LINE__</code> and <code>__FILE__</code> where <code>PANIC</code> is defined and not where it is called. And to halt the kernel it uses a <code>while true</code> loop which goes on infinitely.</div></article><article class=syndicate><h2><a href=https://scientiac.space/syndications/kl-os-2025-12-25/>KL-OS: C Standard Library</a></h2><p class="subtitle --center"><code>2025-12-25</code><div class=syndicate-text><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p>To make a useful kernel we require it to perform tasks like setting a memory chunk to zero, or copying the memory from a source address to destination address. It may have to understand what a boolean is or what NULL is. So, for that we require the "C Standard Library" and hence we need to implement it (or the functions it contains as abstractions to commonly used functions).<p>For this, in <a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-4.md>day 4</a> I utilized <code>clang</code>'s internal C library as well as resorted to writing the functions all by myself.</div></article><nav class=pagination data-style=none><a class=page-nav href=https://scientiac.space/syndicate/posse/page/5/>Old</a><a class=page-nav href=#>1 / 5 </a><a class=page-nav href=https://scientiac.space/syndicate/posse/page/2/>Next</a></nav></div><script defer src=/assets/js/themeSelector.js></script><div class=hidden><a href=https://polymaths.social/@iac rel=me>Fediverse</a></div><div class="hidden h-card"><img class="u-photo icon" alt=scientiac src=/res/thumbnail.png><a class="p-name u-url" href=https://scientiac.space rel=me>scientiac</a><p class=p-note>A Computer Engineering student who loves FOSS and is learning about privacy, the Internet and languages writing about the things he does.</div><footer><p class=codewithlove>I can't think of things to write on a footer. So, just <span class=main-background>imagine</span> something yourself.<p><a href=/series>Series</a> | <a href=/atom.xml>RSS</a> | <a href=https://github.com/scientiac/scientiac.github.io target=_blank>Source Code</a><p>All articles are usable under <a href=https://creativecommons.org/licenses/by-sa/4.0/ target=_blank>CC BY-SA 4.0</a>.</footer><ol id=themeSelector reversed></ol>