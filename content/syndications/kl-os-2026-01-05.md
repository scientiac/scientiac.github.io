+++
title = "KL-OS: File System"
date = 2026-01-05

[taxonomies]
syndicate=["POSSE"]
series=["OS in 1000 LOC"]
+++

{{ bridgy() }}

[Day 15](https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-15.md) was about File System. 

The [book](https://operating-system-in-1000-lines.vercel.app/en/) that I am following has come to an end with **File System** as the final chapter where it teaches to implement `tar` file as a filesystem.

`tar` is an archive format (like zip) that can contain multiple files. It contains file contents, filenames, creation dates, and other information necessary for a filesystem. Compared to common filesystem formats like FAT or ext2, tar has a much simpler data structure.

First a simple directory with two files is made as an example which is then archived/compressed into the `tar` format using the command line `tar` tool. Which, also is added to the `buildscript` before launching the `qemu` VM.

```sh 
(cd disk && tar cf ../disk.tar --format=ustar *.txt)

# The following flag is also added to qemu.
-drive id=drive0,file=disk.tar,format=raw,if=none \
```

To read the filesystem, first, the data structures related to the tar filesystem is defined in `kernel.h`. This implementation has all files read from the disk at boot.

To write to the disk, the contents of the `files` variable is written back to the disk in the tar file format. The `files` variable contains the copy of the `disk` variable declared as a static variable (It is a temporary buffer and, since the stack has a limited size it is preferred to use static variable instead of local `stack` variable.) which contains the disk image.

File read/write system calls are then designed in the `user.c` and `user.h` files and then the system calls are implemented on the kernel files and then the system calls are implemented in the kernel. We also add the read and write commands to the shell.

But, we still have to address the user pointers. 

In RISC-V, the behaviour of `S-Mode` (kernel) can be configured through `sstatus` `CSR`, including SUM (permit Supervisor User Memory access) bit. When SUM is not set, `S-Mode` programs (i.e. kernel) cannot access U-Mode (user) pages.

All we need to do is to set the SUM bit when entering user space and voila! Our OS with a filesystem implementation is now ready.

