+++
title = "KL-OS: Process"
date = 2025-12-29

[taxonomies]
syndicate=["POSSE"]
+++

{{ bridgy() }}

[Day 8](https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-8.md) was about Process. Though, modern operating systems use the concept of threads to provide execution context. We treat processes like individual threads being run for our implementation.

First we define a structure for PCB (Process Control Block). We first define `PROC_UNUSED` and `0` and `PROC_RUNNABLE` as `1`. Then we create a structure for a unit process with the following slots:

- Process ID as an Integer.
- State (*`PROC_UNUSED `or `PROC_RUNNABLE`*) as an Integer as defined before.
- Stack Pointer as a `vaddr_t` (Virtual Address Type).
- Kernel Stack as a list of unsigned `8bit` Integers.

The Kernel Stack is essential for saving the registers while context switching.

Then, we defined the `switch_context` function that does the context switching. It takes
the previous and next stack pointer as arguments and then switches them during execution.
It saves the callee-saved registers into the stack, switches the stack pointer then restores the callee-saved registers from the stack. *The execution context is saved as a temporary local variable on the stack.*

Then, we work on process creation. The process creation function `create_process` takes
in the entry point of the process as a parameter and then returns the process struct.

The `delay` function is also created to act as a sleep style function which just does `nop` (Nothing) for 30000000 clock pulses.

Then a **scheduler** is made to make the context switching more autonomous.
A scheduler is basically a Kernel program which decides the next process.

Then, in the exception handler, we make it so that each process has it's own independent kernel stack. While switching, the contents of `sscratch` are switched too to resume the execution of process from where it was interrupted as if nothing had happened.
