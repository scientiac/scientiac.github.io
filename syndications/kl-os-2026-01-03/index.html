<!doctype html><html lang=en><head><meta charset=utf-8><script>(()=>{try{const a={light:`gruvbox-light`,dark:`night-solis`};const b=window.matchMedia(`(prefers-color-scheme: dark)`).matches;const c=localStorage.theme||(b?a.dark:a.light);document.documentElement.dataset.theme=c}catch(a){}})()</script><link href=/assets/css/themes.css rel=stylesheet><link href=/assets/css/readable.css rel=stylesheet><link href=/assets/css/global.css rel=stylesheet><link href=/assets/css/fonts.css rel=stylesheet><link href=/assets/css/logo.css rel=stylesheet><link href=https://scientiac.space/atom.xml rel=alternate title=RSS type=application/atom+xml><meta content=POSSE property=og:type><meta content=scientiac.space property=og:site_name><meta content=https://scientiac.space/res/thumbnail-light.png property=og:image><title>KL-OS: System Call</title><meta content="KL-OS: System Call" name=og:title><meta content="
Day 13 was about system call.
Similar to SBI Call implementation, the system calls are invoked in a similar way.
The syscall function sets the system call number in the a3 register and the system call arguments in the a0 to a2 registers, then executes the ecall instruction. The ecall instruction is a special instruction used to delegate processing to the kernel. When the ecall instruction is executed, an exception handler is called, and control is transferred to the kernel. The return value from the kernel is set in the a0 register.
The first systemcall implemented is putchar. It takes a character as the first argument and the second and subsequent unused arguments are set to 0.
Then the ecall instruction is handled in the kernel. The calling of ecall can by determined by checking the value of scause. Before calling the handle_syscall function we also add the size of ecall instruction (4) to the value of sepc.
This is because sepc points to the program counter that caused the exception, which points to the ecall instruction. If we don't change it, the kernel goes back to the same place, and the ecall instruction is executed repeatedly.
Then a system call  handler is made and is called from trap handler. It receives a
structure of registers at the time of exception that was saved in the trap handler. It determined the type of system call by checking the value of a3 register.
The system call was then tested with a main print function in shell.c.
An exit system call is also implemented where it takes the first argument as 3 which is defined as SYS_EXIT.
The system call changes the process state to PROC_EXITED, and calls yield to give up the CPU to other processes. The scheduler will only execute processes in PROC_RUNNABLE state, so it will never return to this process. However, PANIC macro is added to cause a panic in case it does return.
A bare-bones shell was then implemented to use the syscalls to perform actions from the user mode.
" name=description><meta content="
Day 13 was about system call.
Similar to SBI Call implementation, the system calls are invoked in a similar way.
The syscall function sets the system call number in the a3 register and the system call arguments in the a0 to a2 registers, then executes the ecall instruction. The ecall instruction is a special instruction used to delegate processing to the kernel. When the ecall instruction is executed, an exception handler is called, and control is transferred to the kernel. The return value from the kernel is set in the a0 register.
The first systemcall implemented is putchar. It takes a character as the first argument and the second and subsequent unused arguments are set to 0.
Then the ecall instruction is handled in the kernel. The calling of ecall can by determined by checking the value of scause. Before calling the handle_syscall function we also add the size of ecall instruction (4) to the value of sepc.
This is because sepc points to the program counter that caused the exception, which points to the ecall instruction. If we don't change it, the kernel goes back to the same place, and the ecall instruction is executed repeatedly.
Then a system call  handler is made and is called from trap handler. It receives a
structure of registers at the time of exception that was saved in the trap handler. It determined the type of system call by checking the value of a3 register.
The system call was then tested with a main print function in shell.c.
An exit system call is also implemented where it takes the first argument as 3 which is defined as SYS_EXIT.
The system call changes the process state to PROC_EXITED, and calls yield to give up the CPU to other processes. The scheduler will only execute processes in PROC_RUNNABLE state, so it will never return to this process. However, PANIC macro is added to cause a panic in case it does return.
A bare-bones shell was then implemented to use the syscalls to perform actions from the user mode.
" name=og:description><link rel="shortcut icon" href=/res/thumbnail.svg type=image/x-icon><meta content="width=device-width,initial-scale=1" name=viewport><meta content="rgb(253, 246, 227)" name=theme-color><script defer src=/assets/js/copy-button.js></script><link href=https://github.com/scientiac rel=me><link href=mailto:spandan@scientiac.space rel=me><link href=https://webmention.io/scientiac.space/webmention rel=webmention><meta content=@iac@polymaths.social name=fediverse:creator><body onload=updateThemeSelector();><div class=logo-container><a href=/> <div class=inner-logo-container></div> </a></div><nav data-style=classy><span><a href=/>Main</a></span><span><a href=/blog>Blog</a></span><span><a href=/syndications>Ping</a></span><span><a href=/more>More</a></span></nav><section class=section-body><div class=container><div id=html-content-holder><div class="h-entry syndicate-inside"><h2 class="p-name title syndicate-inside-title">KL-OS: System Call</h2><div class=syndicate-pagedate><time class="dt-published dateandtag hidden" datetime=2026-01-03T00:00:00Z> 2026-01-03 </time><code class="dt-published dateandtag">2026-01-03</code><code class="u-category dateandtag">POSSE</code></div><a class="u-url hidden" href=https://scientiac.space/syndications/kl-os-2026-01-03/>https://scientiac.space/syndications/kl-os-2026-01-03/</a><div class="hidden p-author h-card"><a class=u-url href=https://scientiac.space rel=me> <img alt="Profile photo of scientiac" class=u-photo src=/res/thumbnail.png> <span class=p-name>scientiac</span> </a></div><div class="section syndicate-inside-text e-content"><a class=u-bridgy-fed hidden href=https://fed.brid.gy/></a><p><a href=https://codeberg.org/scientiac/KL-OS/src/branch/main/progress/day-13.md>Day 13</a> was about system call.<p>Similar to <code>SBI Call</code> implementation, the system calls are invoked in a similar way.<p>The <code>syscall</code> function sets the system call number in the <code>a3</code> register and the system call arguments in the <code>a0</code> to <code>a2</code> registers, then executes the <code>ecall</code> instruction. The <code>ecall</code> instruction is a special instruction used to delegate processing to the kernel. When the <code>ecall</code> instruction is executed, an exception handler is called, and control is transferred to the kernel. The return value from the kernel is set in the <code>a0</code> register.<p>The first <code>systemcall</code> implemented is <code>putchar</code>. It takes a character as the first argument and the second and subsequent unused arguments are set to 0.<p>Then the <code>ecall</code> instruction is handled in the kernel. The calling of <code>ecall</code> can by determined by checking the value of <code>scause</code>. Before calling the <code>handle_syscall</code> function we also add the size of <code>ecall</code> instruction (4) to the value of <code>sepc</code>.<p>This is because <code>sepc</code> points to the program counter that caused the exception, which points to the <code>ecall</code> instruction. If we don't change it, the kernel goes back to the same place, and the <code>ecall</code> instruction is executed repeatedly.<p>Then a <code>system call</code> handler is made and is called from trap handler. It receives a structure of registers at the time of exception that was saved in the trap handler. It determined the type of system call by checking the value of <code>a3</code> register.<p>The system call was then tested with a main print function in <code>shell.c</code>.<p>An <code>exit</code> system call is also implemented where it takes the first argument as <code>3</code> which is defined as <code>SYS_EXIT</code>.<p>The system call changes the process state to <code>PROC_EXITED</code>, and calls yield to give up the CPU to other processes. The scheduler will only execute processes in <code>PROC_RUNNABLE</code> state, so it will never return to this process. However, <code>PANIC</code> macro is added to cause a panic in case it does return.<p>A bare-bones shell was then implemented to use the syscalls to perform actions from the user mode.</div></div></div><div id=webmention><hr><h2>Webmentions</h2><form action=https://webmention.io/scientiac.space/webmention class=webmention-form method=post><div id=email-comment><p>Have you written a <a href=https://indieweb.org/responses>response</a> to this? Let me know the URL, Or, you can send your response via <a href="mailto:iac@scientiac.space?subject=Reply%3A%20KL-OS%3A%20System%20Call">mail:</a><code>iac@scientiac.space</code></div><div class=send-webmention><input name=source type=url><button>Send Webmention</button></div><div><div class="ui message"></div></div><input name=target type=hidden value=https://scientiac.space/syndications/kl-os-2026-01-03/></form><div class=interaction-box></div></div></div><script defer src=/assets/js/themeSelector.js></script></section><div class=hidden><a href=https://polymaths.social/@iac rel=me>Fediverse</a></div><div class="hidden h-card"><img class="u-photo icon" alt=scientiac src=/res/thumbnail.png><a class="p-name u-url" href=https://scientiac.space rel=me>scientiac</a><p class=p-note>A Computer Engineering student who loves FOSS and is learning about privacy, the Internet and languages writing about the things he does.</div><footer><p class=codewithlove>I can't think of things to write on a footer. So, just <span class=main-background>imagine</span> something yourself.<p><a href=/series>Series</a> | <a href=/atom.xml>RSS</a> | <a href=https://github.com/scientiac/scientiac.github.io target=_blank>Source Code</a><p>All articles are usable under <a href=https://creativecommons.org/licenses/by-sa/4.0/ target=_blank>CC BY-SA 4.0</a>.</footer><ol id=themeSelector reversed></ol>